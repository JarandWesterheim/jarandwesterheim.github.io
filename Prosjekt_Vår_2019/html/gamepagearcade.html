<!DOCTYPE html>
<html lang="en" dir="ltr">
  <head>
    <meta charset="utf-8">
    <title>New Arcade</title>
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
    <link rel="stylesheet" href="../css/stylesheet.css">
<link rel="icon" href="../bilder/svg/arcade-svgrepo-com.ico">
    <link href="https://fonts.googleapis.com/css?family=Monoton|Orbitron" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css?family=Press+Start+2P" rel="stylesheet">
    <!-- firebase -->
    <script src="https://www.gstatic.com/firebasejs/5.9.0/firebase.js"></script>
    <script>
      // Initialize Firebase
      var config = {
        apiKey: "AIzaSyALIIVij5Rp162mHTDa8ictgZ3O7YAITi0",
        authDomain: "project-spring-2019.firebaseapp.com",
        databaseURL: "https://project-spring-2019.firebaseio.com",
        projectId: "project-spring-2019",
        storageBucket: "",
        messagingSenderId: "163179103807"
      };
      firebase.initializeApp(config);
    </script>
  </head>
  <body id="arcadebody">
    <header>
      <a id="logo" href="homepage.html">b</a>
      <b><span>new</span>ARCADE</b>
      <a href="homepage.html"><i id="cart" class="fas fa-cart-plus"></i></a>
      <a id="header--user-icon" href="#"><i class="far fa-user"></i></a>
      <i onclick="showDropdown()" id="header--menu-icon" class="fas fa-bars"></i>
      <div id="dropdown" class="header--dropdown hidden">
        <a id="header--dropdown-home" class="header__topic" href="homepage.html">Home</a>
        <a onclick="showDropdownshop()" class="header__topic">Shop<i id="dropdown--shop-arrow" class="fas fa-chevron-down"></i></a>
        <a id="header__subtopic1" class="header__subtopic subtopic--hidden" href="shop.html">all games</a>
        <a id="header__subtopic2" class="header__subtopic subtopic--hidden" href="shop.html#arcade">arcade games</a>
        <a id="header__subtopic3" class="header__subtopic subtopic--hidden" href="shop.html#digital">digital games</a>
        <a id="header__subtopic4" class="header__subtopic subtopic--hidden" href="shop.html#board">board games</a>
        <a class="header__topic" href="homepage.html#reviews">reviews</a>
        <a class="header__topic" href="cart.html">cart<i class="fas fa-cart-plus"></i></a>
        <a class="header__topic" href="user.html">user<i class="far fa-user"></i></a>
      </div>
    </header>
    <main>
      <div class="" id="target">

      </div>
    </main>
    <script type="text/javascript" src="../javascript/javascript.js"></script>
    <script type="text/javascript">
    const target = document.querySelector("#target");

    var url_string = window.location.href
    var url = new URL(url_string);
    var id = url.searchParams.get("id");

    const db = firebase.database();
    const arcade = db.ref("products/arcade/" + id );

    function generateGamepage(snapshot) {
      let chip = snapshot.val();
      target.innerHTML +=`
        <div class="gamepagearcade">
          <div class="gamepagearcade--coverimg">
            <img src="${chip.Image}" alt="">
          </div>
          <div class="gamepagearcade--info">
            <h1 class="gameapagearcade--gamename">${chip.Name}</h1>
            <p>${chip.Info}</p>
            <p>Scoring: <b>${chip.Scoring}</b></p>
            <p>Avaiable on: <b>${chip.Platform}</b></p>
            <b>$${chip.Price}</b>
            <button onclick="addCart()" class="add-to-cart" id=x"add-to-cart"><h2>Add to cart <i class="fas fa-cart-plus"></h2></i></button>
          </div>
          <div id="canvas--container">
          <button class="demo-button" onclick="load${chip.Name}()">load demo <i class="fas fa-gamepad"></i></button>
            <canvas id="${chip.gamecode}" width="${chip.gamewidth}" height="${chip.gameheight}"></canvas>
          </div>

        </div>
      `
    }
    arcade.on("value", generateGamepage);

    function loadSnake() {
      console.log("Loading Snake")
      window.alert("You change the snakes direction by using W,A,S and D. Good luck!")
      var canvas = document.getElementById("snake");
      var context = canvas.getContext('2d');
      var grid = 16;
      var count = 0;

      var snake = {
        x: 160,
        y: 160,

        // snake velocity. moves one grid length every frame in either the x or y direction
        dx: grid,
        dy: 0,

        // keep track of all grids the snake body occupies
        cells: [],

        // length of the snake. grows when eating an apple
        maxCells: 4
      };
      var apple = {
        x: 320,
        y: 320
      };
      // get random whole numbers in a specific range
      // @see https://stackoverflow.com/a/1527820/2124254
      function getRandomInt(min, max) {
        return Math.floor(Math.random() * (max - min)) + min;
      }
      // game loop
      function loop() {
        requestAnimationFrame(loop);
        // slow game loop to 15 fps instead of 60 (60/15 = 4)
        if (++count < 4) {
          return;
        }
        count = 0;
        context.clearRect(0,0,canvas.width,canvas.height);
        // move snake by it's velocity
        snake.x += snake.dx;
        snake.y += snake.dy;
        // wrap snake position horizontally on edge of screen
        if (snake.x < 0) {
          snake.x = canvas.width - grid;
        }
        else if (snake.x >= canvas.width) {
          snake.x = 0;
        }

        // wrap snake position vertically on edge of screen
        if (snake.y < 0) {
          snake.y = canvas.height - grid;
        }
        else if (snake.y >= canvas.height) {
          snake.y = 0;
        }
        // keep track of where snake has been. front of the array is always the head
        snake.cells.unshift({x: snake.x, y: snake.y});
        // remove cells as we move away from them
        if (snake.cells.length > snake.maxCells) {
          snake.cells.pop();
        }
        // draw apple
        context.fillStyle = 'red';
        context.fillRect(apple.x, apple.y, grid-1, grid-1);
        // draw snake one cell at a time
        context.fillStyle = 'green';
        snake.cells.forEach(function(cell, index) {

          // drawing 1 px smaller than the grid creates a grid effect in the snake body so you can see how long it is
          context.fillRect(cell.x, cell.y, grid-1, grid-1);
          // snake ate apple
          if (cell.x === apple.x && cell.y === apple.y) {
            snake.maxCells++;
            // canvas is 400x400 which is 25x25 grids
            apple.x = getRandomInt(0, 25) * grid;
            apple.y = getRandomInt(0, 25) * grid;
          }
          // check collision with all cells after this one (modified bubble sort)
          for (var i = index + 1; i < snake.cells.length; i++) {

            // snake occupies same space as a body part. reset game
            if (cell.x === snake.cells[i].x && cell.y === snake.cells[i].y) {
              snake.x = 160;
              snake.y = 160;
              snake.cells = [];
              snake.maxCells = 4;
              snake.dx = grid;
              snake.dy = 0;
              apple.x = getRandomInt(0, 25) * grid;
              apple.y = getRandomInt(0, 25) * grid;
            }
          }
        });
      }
      // listen to keyboard events to move the snake
      document.addEventListener('keydown', function(e) {
        // prevent snake from backtracking on itself by checking that it's
        // not already moving on the same axis (pressing left while moving
        // left won't do anything, and pressing right while moving left
        // shouldn't let you collide with your own body)

        // left arrow key
        if (e.which ===65&& snake.dx === 0) {
          snake.dx = -grid;
          snake.dy = 0;
        }
        // up arrow key
        else if (e.which === 87 && snake.dy === 0) {
          snake.dy = -grid;
          snake.dx = 0;
        }
        // right arrow key
        else if (e.which === 68 && snake.dx === 0) {
          snake.dx = grid;
          snake.dy = 0;
        }
        // down arrow key
        else if (e.which === 83 && snake.dy === 0) {
          snake.dy = grid;
          snake.dx = 0;
        }
      });
      // start the game
      requestAnimationFrame(loop);

    }





    function loadTetris() {
      console.log("Loading Tetris");
      window.alert("You move the blocks with LEFT ARROW and RIGHT ARROW. You make the blocks drop down faster with X. You rotate the blocks with Z. To start and pause the game, use ENTER. Good luck!")
      var SQ      = 25;   // square side in pixels
      var HCOUNT  = 10;   // horizontal width in squares
      var VCOUNT  = 18;   // vertical width in squares
      var WIDTH   = SQ * HCOUNT;
      var HEIGHT  = SQ * VCOUNT;
      var SPEED     = 450; // game speed in the loop.
      var DROPSPEED = 50;  // game speed when dropping objects.
      var ORIGSPEED = 450; // original game speed
      var BGCOLOR = '#fff';

      var canvas = document.getElementById('game');
      canvas.width = WIDTH;
      canvas.height = HEIGHT;

      var ctx = canvas.getContext('2d');

      // Object definitions
      // Cube, Left L, Rright L, S shape, Z shape, T shape, Pipe (I)
      // '0' is the normal orientation
      // '1' is the object rotated 90 degrees clockwise
      // '2' is the object rotated 180 degrees clockwise
      // '3' is the object rotated 270 degrees clockwise

      var objects = [
        {    // Cube
          fill: '#afa',
          0: [[0,0], [1,1], [0,1], [1,0]], 1: [[0,0], [1,1], [0,1], [1,0]],
          2: [[0,0], [1,1], [0,1], [1,0]], 3: [[0,0], [1,1], [0,1], [1,0]]
        }, { // Normal L
          fill: '#faa',
          0: [[0,0],[1,0],[1,1],[1,2]], 1: [[0,1],[1,1],[2,1],[2,0]],
          2: [[0,0],[0,1],[0,2],[1,2]], 3: [[0,0],[1,0],[2,0],[0,1]]
        }, { // Reverse L
          fill: '#aaf',
          0: [[0,0],[1,0],[0,1],[0,2]], 1: [[0,0],[1,0],[2,0],[2,1]],
          2: [[1,0],[1,1],[1,2],[0,2]], 3: [[0,0],[0,1],[1,1],[2,1]]
        }, { // S - shaped
          fill: '#ffa',
          0: [[0,1],[1,1],[1,0],[2,0]], 1: [[0,0],[0,1],[1,1],[1,2]],
          2: [[0,1],[1,1],[1,0],[2,0]], 3: [[0,0],[0,1],[1,1],[1,2]]
        }, { // Z - shaped
          fill: '#aff',
          0: [[0,0],[1,0],[1,1],[2,1]], 1: [[1,0],[1,1],[0,1],[0,2]],
          2: [[0,0],[1,0],[1,1],[2,1]], 3: [[1,0],[1,1],[0,1],[0,2]]
        }, { // T - shaped
          fill: '#faf',
          0: [[0,0],[1,0],[2,0],[1,1]], 1: [[0,-1],[0,0],[0,1],[1,0]],
          2: [[0,0],[1,-1],[2,0],[1,0]], 3: [[2,-1],[1,0],[2,0],[2,1]]
        }, { // Pipe
          fill: '#aaa',
          0: [[0,0], [0,1], [0,2], [0,3]], 1: [[-1,1],[0,1],[1,1],[2,1]],
          2: [[0,0], [0,1], [0,2], [0,3]], 3: [[-1,1],[0,1],[1,1],[2,1]]
        }
      ];
      // current object
      var object = null;
      // object's orientation
      var or = 2;
      // last position of the object
      var objectPos = [];
      // horizontal position (offset) of the object
      var hpos  = 4;
      // vertical position (offset) of the object
      var vpos  = 0;
      // whether this is the first tick of a new object
      var newOb = true;
      // last tick's time
      var t = new Date();
      // If true the last object should be glued
      var glue = false;
      // The Map, Grid, Matrix .. whatever
      // Note: The map has 3 types of fields (squares). Empty fields have
      // value 1, fields that are occupied by the current moving object have value 2,
      // and fields that are occupied by settled objects have a string value of the
      // color in which they should be displayed (object's 'fill' property)
      var Map = [];

      function resetGame(){
        for( var i = 0; i < HCOUNT; i++ ){
          Map[i] = [];
          for( var j = 0; j < VCOUNT; j++ )
            Map[i][j] = 1;
        }
        glue = false, newOb = true, vpos = or = 0, hpos  = 4;
      }
      resetGame();

      // The main game logic loop
      function tick() {
        // Clears the map cells where the object used to be in the previous tick
        var color = 1;
        var removeLines = false;
        if( glue ){
          removeLines = true;
          glue  = false;
          newOb = true;
          color = object.fill;
          vpos  = 0;
          hpos  = 4;
          or    = 0;
        }
        for( var i=0; i < objectPos.length; i++ )
          Map[ objectPos[i][0] ][ objectPos[i][1] ] = color;
        objectPos = [];

        removeLines && removeFullLines();

        if( newOb ) {
          // next random object to appear
          object = objects[ Math.floor( Math.random() * objects.length ) ];
          // compensates the vpos for the object's height
          //vpos -= Math.max( object[or][0][1], object[or][1][1], object[or][2][1], object[or][3][1] ) + 1;
        }

        var x, y, olength = object[or].length;

        // Place the object on the map
        // The object won't be out of horizontal bounds
        for( i=0; i < olength; i++ ) {
          x = hpos + object[or][i][0];
          y = vpos + object[or][i][1];

          if( Map[ x ][ y ] ) {
            Map[ x ][ y ] = 2;
            objectPos.push( [ x, y ] );
          }
        }

        // Check the time difference from the last tick
        // This dictates the game speed
        var t1 = new Date();
        if( t1 - t > SPEED ){
          // if it's time for a new tick
          var columns = {}
          for( i=0; i < olength; i++ ) {
            x = hpos + object[or][i][0];
            y = vpos + object[or][i][1];
            if( y<0 )
              continue;
            !isNaN(columns[x]) || (columns[x] = y);
            columns[x] = Math.max( columns[x], y );
          }

          for( i in columns )
            if( columns[i] == VCOUNT - 1 || Map[i][columns[i] + 1] != 1 ){
              glue = true;
              if( newOb ) {
                alert("Game Over");
                resetGame();
              }
              SPEED = ORIGSPEED;
              return;
            }
          t = t1;
          vpos += 1;
        }

        newOb = false;
      }

      // Scans the map for filled lines and removes them.
      function removeFullLines(){
        var line, j, i, k;
        for( i = VCOUNT-1; i > 0; i-- ){
          line = true;
          for( j=0; j < HCOUNT; j++ )
            if( typeof Map[j][i] != 'string' )
              line = false;

          if( line ) {
            for( k = i; k > 0; k-- )
              for( j = 0; j < HCOUNT; j++ )
                Map[j][k] = Map[j][k-1];
            i++;
          }
        }
      }

      // Checks if the object can be moved to the side
      function canMove( side ){
        var maxFunc = side == 1 ? Math.max : Math.min;
        var rows = {}, x, y;
        for( var i=0, olength=object[or].length; i < olength; i++ ) {
          y = vpos + object[or][i][1];
          x = hpos + object[or][i][0] + side; // temporarily move the object sideways
          !isNaN(rows[y]) || ( rows[y] = x );  // get the leftmost/rightmost square in each row
          rows[y] = maxFunc( rows[y], x );
        }
        // Check if the leftmost/rightmost square is in an illegal position
        for( i in rows )
          if( rows[i] < 0 || rows[i] > HCOUNT-1 || Map[ rows[i] ][ i ] != 1 )
            return false;
        return true;
      }

      // Checks if the element can be rotated.
      function canRotate() {
        var newOr = (or + 1) % 4;
        var to = object[ newOr ], x, y;
        for( var i=0, olength=to.length; i < olength; i++ ){
          x = hpos + to[i][0];
          y = vpos + to[i][1];

          // If we want to rotate an object at the edge, try
          // moving that object to the side to see if it can rotate.
          if( !Map[x] ) {
            var mod = x < 0 ? 1 : -1;
            hpos += mod;
            if( canRotate() ) return true;
            else hpos -= mod;
          }

          if( !Map[x][y] || typeof Map[x][y] === 'string' )
            return false;
        }

        return true;
      }

      // draws a line from point (fromx, fromy) to point (tox, toy)
      function line( fromx, fromy, tox, toy ){
        ctx.beginPath();
        ctx.moveTo( fromx, fromy );
        ctx.lineTo( tox, toy );
        ctx.stroke();
      }

      // The grid line styles
      ctx.strokeStyle = '#999';
      ctx.lineWidth = .5;
      function drawMap() {
        // clear map and draw grid
        ctx.clearRect( 0, 0, WIDTH, HEIGHT );
        var currentSquare, w, h, i;
        // this loop draws the current map state
        for( w = 0; w < HCOUNT; w++ ){
          ctx.save();
          ctx.translate( w * SQ, 0 ); // Move the canvas horizontally
          for( h = 0; h < VCOUNT; h++ ){
            currentSquare = Map[w][h];
            ctx.save();
            ctx.translate( 0, h * SQ ); // Move the canvas vertically
            if( currentSquare === 2) {
              ctx.fillStyle = object.fill;
              ctx.fillRect( 0, 0, SQ, SQ );
            }
            else if( typeof currentSquare === 'string' ) {
              ctx.fillStyle = currentSquare;
              ctx.fillRect( 0, 0, SQ, SQ );
            }
            ctx.restore();
          }
          ctx.restore();
        }
        // draws the grid
        for( i = 1; i < WIDTH; i++ )
          line( i*SQ, 0, i*SQ, HEIGHT );
        for( i = 1; i < HEIGHT; i++ )
          line( 0, i*SQ, WIDTH, i*SQ );
      }

      var running = false, drawLoop, tickLoop;
      document.onkeydown = function(e) {
        var key = e.which;

        if( running && key === 90 && canRotate() ) // a - rotate
          or = ++or % 4;

        else if( key === 88 ) { // down - drop the object by increasing game speed
          SPEED = DROPSPEED;
        }

        else if( key === 13 ) { // s - stop (pause)
          if( running ){
            clearInterval( drawLoop );
            clearInterval( tickLoop );
          }
          else{
            drawLoop = setInterval(drawMap, 50);
            tickLoop = setInterval(tick, 50);
          }
          running = !running;
        }

        else if( running && key ===37&& canMove(-1) ) // left - move left
          hpos--;
        else if( running && key ===39&& canMove(1) ) // right - move right
          hpos++;
      }

      document.onkeyup = function(e) { // cancel drop
        if( e.which === 83 )
          SPEED = ORIGSPEED;
      }
    }

    function loadMario() {
      window.alert("MARIO GAME IS NTO YET IMPLEMENTED, need to do some extra coding. Hoepfully up soon")
    }
    </script>

    <footer><h2><span>new</span>ARCADE</h2></footer>
  </body>
</html>
